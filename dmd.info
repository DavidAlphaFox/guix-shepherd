Dies ist dmd.info, hergestellt von Makeinfo Version 4.0 aus dmd.texi.

INFO-DIR-SECTION System software
START-INFO-DIR-ENTRY
* dmd Manual: (dmd).    The manual of the dmd service manager.
END-INFO-DIR-ENTRY


File: dmd.info,  Node: Top,  Next: Introduction,  Up: (dir)

dmd Manual
**********

   Copyright (C) 2002, 2003 Wolfgang Ja"hrling

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the file COPYING.DOC of
the dmd distribution.

* Menu:

* Introduction::      Introduction to the dmd service manager.
* Jump Start::        How to do simple things with dmd.
* deco and dmd::      User interface to service management.
* Services::          Details on services.
* Runlevels::         Details on runlevels.
* Misc Facilities::   Generally useful things provided by dmd.
* Internals::         Hacking dmd.

* Concept Index::
* Procedure and Macro Index::
* Variable Index::
* Type Index::


File: dmd.info,  Node: Introduction,  Next: Jump Start,  Prev: Top,  Up: Top

Introduction
************

   This manual documents the "dmd" service manager.  It is used to
start and stop system services (typically daemons).  It ensures that
this will work - by automatically starting services that are needed for
another service to run and avoiding that conflicting services are
started at the same time.  It does so in a very flexible way.

   As with all flexible software, it takes some work to learn how to use
it.  To make it as easy as possible for you, this manual contains a
chapter that enables you to start using dmd without reading about all
the details first *Note Jump Start::.  The second chapter *Note deco
and dmd:: describes the programs in detail.  The other chapters provide
a reference with examples, where all possibilities that dmd provides are
explained.  An exception is the last chapter, which contains
information for those brave enough to modify dmd itself.

   The name dmd stands for "Daemon Managing Daemons" (or
"Daemons-Managing Daemon"?).

   This program is written in "Guile", an implementation of the Scheme
programming language, using the "GOOPS" extension for
object-orientation, therefore Guile is also used as the language for
the configuration.  When you want to make use of advanced features of
dmd, you should know how to work with Guile and GOOPS, but it has been
tried to make using basic features of dmd possible without knowing how
to program in Scheme at all.


File: dmd.info,  Node: Jump Start,  Next: deco and dmd,  Prev: Introduction,  Up: Top

Jump Start
**********

   This chapter gives a short overview of dmd.  It is enough if you just
need the basic features of it.  As it is not assumed that readers are
familiar with all the involved issues, a very experienced user might be
annoyed by the often very detailed descriptions in this introduction.
Those users are encouraged to just skip to the reference section.

   Note that all the full file names in the following text are based on
the assumption that you have installed dmd with an empty prefix.  If
your dmd installation for example resides in `/usr/local' instead, add
this directory name in front of the absolute file names mentioned below.

   When dmd gets started, it reads a configuration file.  When it is
started with superuser priviledges, it tries to use `/etc/dmdconf.scm',
when started as normal user, it looks for a file called `.dmdconf.scm'
in the users home directory.  With the option `--config' (or, for
short, `-c'), you can specify where to look instead.  So if you want to
start dmd with an alternative file, use one of the following commands:

     dmd --config=/etc/dmdconf.scm.old
     dmd -c /etc/dmdconf.scm.old

   As its name suggests, dmd is just a daemon that (usually) runs in the
background, so you will not interact with it directly.  After it is
started, dmd will listen on a socket special file, usually
`/var/run/dmd/$USER/default', for further commands.  You use the tool
"deco" to send these commands to dmd.  Usage of deco is simple and
straight forward: To start a service called `apache', you use:

     deco start apache

   When you do this, all its dependencies will get resolved.  For
example, a webserver is quite likely to depend on working networking,
thus it will depend on a service called `network'.  So if you want to
start `apache', and `network' is not yet running, it will automatically
be started as well.  In the same way, you can stop a service and all
the services that depend on it will be stopped.  Using the example
above, if you stop `network', the service `apache' will be stopped as
well - Which makes perfectly sense, as it can not work without the
network being up.  To actually stop a service, you use the following,
probably not very surprising, command:

     deco stop networking

   There are two more actions you can perform on every service: The
actions `enable' and `disable' are used to prevent and allow starting
of the particular service.  If a service is intended to be restarted
whenever it terminates (how this can be done will not be covered in
this introduction), but it is respawning too often in a short period of
time (by default 5 times in 5 seconds), it will automatically be
disabled.  After you have fixed the problem that caused it from being
respawned too fast, you can start it again with the commands:

     deco enable foo
     deco start foo

   But there is far more you can do than just that.  Services can not
only simply depend on other services, they can also depend on _virtual_
services.  A virtual service is a service that is provided by one or
more service additionally.  For instance, a service called `exim' might
provide the virtual service `mailer-daemon'.  That could as well be
provided by a service called `smail', as both are mailer-daemons.  If a
service needs any mailer-daemon, no matter which one, it can just
depend on `mailer-daemon', and one of those who provide it gets started
(if none is running yet) when resolving dependencies.  The nice thing is
that, if trying to start one of them fails, dmd will go on and try to
start the next one, so you can also use virtual services for specifying
_fallbacks_.

   Additionally to all that, you can perform service-specific actions.
Coming back to our original example, `apache' is able to reload its
modules, therefore the action `reload-modules' might be available:

     deco reload-modules apache

   The service-specific actions can only be used when the service is
started, i.e. the only thing you can do to a stopped service is
starting it.  An exception exists, see below.  (If you may at some
point find this too restrictive because you want to use variants of the
same service which are started in different ways, consider using
different services for those variants instead, which all provide the
same virtual service and thus conflict with each other, if this is
desired.  That's one of the reasons why virtual services exist, after
all.)

   There are two actions which are special, because even if services
can implement them on their own, a default implementation is provided
by dmd (another reason why they are special is that the default
implementations can be called even when the service is not running;
this inconsistency is just to make it more intuitive to get information
about the status of a service, see below).

   These actions are `restart' and `status'.  The default
implementation of `restart' calls `stop' and `start' on the affected
service in order, the `status' action displays some general information
about the service, like what it provides, what it depends on and with
which other services it conflicts (because they provide a virtual
service that is also provided by that particular service).

   Another special action is `list-actions', which displays a list of
the additional actions a service provides; obviously, it can also be
called when the service is not running.  Services cannot provide their
own implementation of `list-actions'.

   A special service is `dmd', which is used for controlling dmd
itself.  It implements various actions.  For example, the `status'
action displays which services are started and which ones are stopped,
whereas `detailed-status' has the effect of applying the default
implementation of `status' to all services one after another.  The
`silent' and `verbose' actions disable and enable the output of dmd,
respectively.  The `load' action is unusual insofar as it shows a
feature that is actually available to all services, but which we have
not seen yet: It takes an additional argument.  You can use `load' to
load arbitrary code into dmd at runtime, like this:

     deco load dmd ~/additional-services.scm

   This is enough now about the `deco' and `dmd' programs, we will now
take a look at how to configure dmd.  In the configuration file, we
need mainly the definition of services.  We can also do various other
things there, like starting a few services already.

   FIXME: Finish.  For now, look at the `examples/' subdirectory.

     ...

   Ok, to summerize:

   * dmd is a daemon, deco the program that controls it.

   * You can start, stop, restart, enable and disable every service, as
     well as display its status.

   * You can perform additional service-specific actions, which you can
     also list.

   * Actions can have arguments.

   * You can display the status of a service, even if the service does
     not provide a specific implementation for this action.  The same
     is true for restarting.

   * The `dmd' service is used to control dmd itself.


File: dmd.info,  Node: deco and dmd,  Next: Services,  Prev: Jump Start,  Up: Top

deco and dmd
************

   The daemon that runs in the background and is responsible for
controlling the services is "dmd", while the user interface tool is
called "deco", the "DaEmon COntroller"(1).  To perform an action, like
stopping a service or calling an extra-action of a service, you use the
deco program.  It will communicate with dmd over a Unix Domain Socket.

   Thus, you start dmd once, and then always use deco whenever you want
to do something service-related.  Since deco passes its current working
directory to dmd, you can pass relative file names without trouble.
Both dmd and deco understand the standard arguments `--help',
`--version' and `--usage'.

* Menu:

* Invoking dmd::    How to start the service damon.
* Invoking deco::   Controlling daemons.

   ---------- Footnotes ----------

   (1) Some people might argue that it actually is short for
"decoration", indicating that it is useless. :-)


File: dmd.info,  Node: Invoking dmd,  Next: Invoking deco,  Up: deco and dmd

Invoking dmd
============

   The `dmd' program has the following synopsis:

     dmd [OPTION...]

   It accepts the following options:

`-c FILE'
`--config=FILE'
     Read FILE as the configuration script on startup.

`-I'
`--insecure'
     Do not check if the directory where the socket - from which we are
     going to receive commands - is located has secure permissions set.
     If this option is not specified, dmd will abort if the
     permissions are set to something that is considered dangerous.

`-l [FILE]'
`--logfile[=FILE]'
     Log output into FILE, or if FILE is not given, `/var/log/dmd.log'
     when running as superuser, ~/.DMD.LOG otherwise.

`-p [FILE]'
`--persistency[=FILE]'

`-S'
`--silent'
     Don't write to standard output.

`-s FILE'
`--socket=FILE'
     Receive further commands on the socket special file FILE.  If this
     option is not specified, `/var/run/dmd/$USER/default' is taken.
     If `none' is specified as file name, the commands will be read
     from standard input.  Note that you can still use a socket with
     the name `none' if you specify the directory name as well, like
     this: `./none'.

`--quiet'
     Synonym for `--silent'.


File: dmd.info,  Node: Invoking deco,  Prev: Invoking dmd,  Up: deco and dmd

Invoking deco
=============

   The `deco' command has the following synopsis:

     deco [OPTION...] ACTION SERVICE [ARG...]

   It causes the ACTION of the SERVICE to be invoked.  For each action,
you should pass the appropriate ARGs.  Actions that are available for
every service are start, stop, restart, status, enable and disable.

   If you pass a file name as an ARG, it will be passed as-is to dmd,
thus if it is not an absolute name, it is local to the current working
directory of dmd, not to deco.

   The `deco' command understands the following options:

`-I'
`--insecure'
     Do not check if the directory where the socket - from which we are
     going to receive output from dmd - is located has secure
     permissions set.  If this option is not specified, deco will abort
     if the permissions are set to something that is considered
     dangerous.

`-r FILE'
`--result-socket=FILE'
     Receive the output from dmd on the socket special file FILE.  By
     default, /var/run/dmd/$USER/deco is used.

`-s FILE'
`--socket=FILE'
     Send commands to the socket special file FILE. If this option is
     not specified, /var/run/dmd/$USER/default is taken.


File: dmd.info,  Node: Services,  Next: Runlevels,  Prev: deco and dmd,  Up: Top

Services
********

   The "service" is obviously a very important concept of dmd.  On the
Guile-level, a service is represented as an instance of the class
`<service>'.  When creating an instance of it, you can specify the
initial values of its slots, and you actually must do this for some of
the slots.

* Menu:

* Slots of services::            What a <service> object consists of.
* Methods of services::          What you can do with a <service> object.
* Service Convenience::          How to conveniently work with services.
* Service De- and Constructors:: Commonly used ways of starting and
                                   stopping services.
* Service Examples::             Examples that show how services are used.
* The dmd and unknown services:: Special services in dmd.


File: dmd.info,  Node: Slots of services,  Next: Methods of services,  Up: Services

Slots of services
=================

   A service has the following slots, all of which can be initialized
with a keyword (i.e. `#:provides', used when creating the object) of
the same name, except where stated otherwise.  You should not access
them directly with `slot-ref' or `slot-set!' usually, use the methods
of the service class *Note Methods of services:: instead.

   * `provides' is a list of symbols that are provided by the service.
     A symbol can only be provided by one service running at a time,
     i.e. if two services provide the same symbol, only one of them can
     run, starting the other one will fail.  Therefore, these symbols
     are mainly used to denote conflicting services.  The first symbol
     in the list is the canonical name for the service, thus it must be
     unique.  This slot has no default value and must therefore be
     initialized.

   * `requires' is, like `provides', a list of symbols that specify
     services.  In this case, they name what this service depends on,
     i.e. before the service can be started, services that provide
     those symbols must be started.  If a required symbol is provided by
     several services, one will be started.  By default, this slot
     contains the empty list.

   * `running' is a hook that can be used by each service in its own
     way.  The default value is `#f', which indicates that the service
     is not running. When an attempt is made to start the service, it
     will be set to the return value of the procedure in the `start'
     slot.  It will also be passed as an argument to the procedure in
     the `stop' slot.  This slot can not be initialized with a keyword.

   * `respawn?' specifies whether the service should be respawned by
     dmd.  If this slot has the value `#t', then assume the `running'
     slot specifies a child process PID and restart the service if that
     process terminates.  Otherwise this slot is `#f', which is the
     default.  See also the `last-respawns' slot.

   * `start' contains the "constructor" for the service, which will be
     called to start the service.  (Therefore, it is not a constructor
     in the sense that it initializes the slots of a `<service>'
     object.)  This must be a procedure that accepts any amount of
     arguments, which will be the additional arguments supplied by the
     user.  If the starting attempt failed, it must return `#f'.  The
     value will be stored in the `running' slot.  The default value is
     a procedure that returns `#t' and performs no further actions,
     therefore it is desirable to specify a different one usually.

   * `stop' is, similar to `start', a slot containing a procedure.  But
     in this case, it gets the current value of the `running' slot as
     first argument and the user-supplied arguments as further
     arguments; it gets called to stop the service.  Its return value
     will again be stored in the `running' slot, so that it should
     return `#f' if it is now possible again to start the service at a
     later point.  The default value is a procedure that returns `#f'
     and performs no further actions.

   * `extra-actions' specifies the additional actions that can be
     performed on a service when it is running.  A typical example for
     this is the `restart' action.  The macro `make-extra-actions'
     *Note Service Convenience:: is provided to abstract the actual data
     representation format for this slot.  (It actually is a hash
     currently.)

   * `enabled?' cannot be initialized with a keyword, and contains `#t'
     by default.  When the value becomes `#f' at some point, this will
     prevent the service from getting started.  A service can be
     enabled and disabled with the methods `enable' and `disable',
     respectively *Note Methods of services::.

   * `last-respawns' cannot be initialized with a keyword and is only
     ever used when the `respawn?' slot contains `#t'; it is a circular
     list with `(car respawn-limit)' elements, where each element
     contains the time when it was restarted, initially all 0, later a
     time in seconds since the Epoch.  The first element is the one
     that contains the oldest one, the last one the newest.

   * `stop-delay?' being false causes the `stop' slot to be unused;
     instead, stopping the service will just cause the
     `waiting-for-termination?' slot be set to `#t'.

   * `waiting-for-termination?' cannot be initialized with a keyword
     and should not be used by others, it is only used internally for
     respawnable services when the `stop-delay?' slot contains a true
     value.  `waiting-for-termination?' contains `#t' if the service is
     still running, but the user requested that it be stopped, in which
     case if the service terminates the next time, the respawn handler
     will not start it again.

     otherwise `#f'.



File: dmd.info,  Node: Methods of services,  Next: Service Convenience,  Prev: Slots of services,  Up: Services

Methods of services
===================

 - method: start (obj <service>)
     Start the service OBJ, including all the services it depends on.
     It tries quite hard to do this: When a service that provides a
     required symbol can not be started, it will look for another
     service that also provides this symbol, until starting one such
     service succeeds.  There is some room for theoretical improvement
     here, of course, but in pratice the current strategy already works
     very well.  This method returns the new value of the `running' slot
     *Note Slots of services::, which is `#f' if the service could not
     be started.

 - method: stop (obj <service>)
     This will stop the service OBJ, trying to stop services that
     depend in it first, so they can be shutdown cleanly.  If this will
     fail, it will continue anyway.  Stopping of services should usually
     succeed, though.  Otherwise, the behaviour is very similar to the
     `start' method.  The return value is also the new `running' value,
     thus `#f' if the service was stopped.

 - method: extra-action (obj <service>) action . args
     Calls the extra-action ACTION (a symbol) of the service OBJ, with
     the specified ARGS, which are dependend on the particular
     extra-action.

 - method: conflicts-with (obj <service>)
     Returns a list of the canonical names of services that conflict
     with the service OBJ.

 - method: canonical-name (obj <service>)
     Returns the canonical name of OBJ, which is the first element of
     the `provides' list.

 - method: provided-by (obj <service>)
     Returns which symbols are provided by OBJ.

 - method: required-by (obj <service>)
     Returns which symbols are required by OBJ.

 - method: running? (obj <service>)
     Returns whether the service OBJ is running.

 - method: respawn? (obj <service>)
     Returns whether the service OBJ should be respawned if it
     terminates.

 - method: default-display-status (obj <service>)
     Display status information about OBJ.  This method is called when
     the user performs the extra-action `status' on OBJ, but there is
     no specific implementation given for it.  It is also called when
     `detailed-status' is applied on `dmd'.


File: dmd.info,  Node: Service Convenience,  Next: Service De- and Constructors,  Prev: Methods of services,  Up: Services

Service Convenience
===================

   In addition to the facilities listed below, there are also some
procedures that provide commonly needed constructors and destructors
for services *Note Service De- and Constructors::.

 - procedure: register-services . services
     Register all SERVICES, so that they can be taken into account when
     trying to resolve dependencies.

 - procedure: lookup-services name
     Return a list of all registered services which provide the symbol
     NAME.

 - macro: make-extra-actions (name proc) ...
     This macro is used to create a value for the `extra-actions' slot
     of a service object *Note Slots of services::.  Each NAME is a
     symbol and each PROC the corresponding procedure that will be
     called to perform the action.  A PROC has one argument, which will
     be the current value of the `running' slot of the service.

 - method: start (obj <symbol>)
     Start a registered service providing OBJ.

 - method: stop (obj <symbol>)
     Stop a registered service providing OBJ.

 - method: extra-action (obj <symbol>) action . args
     The same as the `extra-action' method of class `<service>', but
     uses a service that provides OBJ and is running.

 - procedure: for-each-service proc
     Call PROC, a procedure taking one argument, once for each
     registered service.

 - procedure: find-running services
     Check if any of SERVICES is running.  If this is the case, return
     its canonical name.  If not, return `#f'.  Only the first one will
     be returned; this is because this is mainly intended to be applied
     on the return value of `lookup-services'.


File: dmd.info,  Node: Service De- and Constructors,  Next: Service Examples,  Prev: Service Convenience,  Up: Services

Service De- and Constructors
============================

   All of the procedures listed below return procedures generated from
the supplied arguments.  These procedures take one argument in the case
of destructors and no arguments in the case of constructors.

 - procedure: make-system-constructor . command
     The returned procedure will execute COMMAND in a shell and return
     `#t' if execution was successful, otherwise `#f'.  For
     convenience, it takes multiple arguments which will be
     concatenated first.

 - procedure: make-system-destructor . command
     Similar to `make-system-constructor', but returns `#f' if
     execution of the COMMAND was successful, `#t' if not.

 - procedure: make-childexec-constructor program . args
     The returned procedure will fork a child process and execute
     PROGRAM with the additional arguments ARGS.  Note that you don't
     have to supply the program name as the first argument again, like
     it is necessary for `execl' and friends.  It returns the pid of
     the child process.

 - procedure: make-kill-destructor signal
     Returns a procedure that sends SIGNAL to the pid which it takes as
     argument.  This _does_ work together with respawning services,
     because in that case the `stop' method of the `<service>' class
     sets the `running' slot to `#f' before actually calling the
     destructor; if it would not do that, killing the process in the
     destructor would immediatelly respawn the service.


File: dmd.info,  Node: Service Examples,  Next: The dmd and unknown services,  Prev: Service De- and Constructors,  Up: Services

Service Examples
================

   FIXME: This needs a lot of work.

   You can create a service and then register it this way:

     (define apache (make <service>
                          #:provides '(apache)
                          #:start (...)
                          #:stop (...)))
     (register-services apache)

   However, as you usually won't need a variable for the service, you
can pass it directly to `register-services'.  Here is an example that
also specifies some more initial values for the slots:

     (register-services
       (make <service>
             #:provides '(apache-2.0 apache httpd)
             #:requires '()
             #:start (...)
             #:stop (...)
             #:extra-actions (make-extra-actions
                               (reload-modules (...))
                               (restart (...)))))


File: dmd.info,  Node: The dmd and unknown services,  Prev: Service Examples,  Up: Services

The `dmd' and `unknown' services
================================

   The service `dmd' is special, because it is used to control dmd
itself.  It provides the following extra-actions (in addition to
`enable', `disable' and `restart' which do not make sense here).

``status''
     Displays which services are started and which ones are not.

``detailed-status''
     Displays detailed information about every registered service.

``load FILE''
     Evaluate the Scheme code in FILE.

``silent''
     Don't send output to dmd's standard output, only to deco.

``verbose''
     Undo what `silent' did.

``daemonize''
     Fork and go into the background.  This should be called before
     respawnable services are started, as otherwise we would not get the
     `SIGCHLD' signals when they terminate.

``enable-persistency''
     When terminating, safe the list of running services in a file.

``disable-persistency''
     Don't safe the list of running services when terminating.

   The `unknown' service must be defined by the user and if it exists,
is used as a fallback whenever we try to invoke an unknown action of an
existing service or use a service that does not exist.  This is useful
only in few cases, but enables you to do various sorts of unusual
things.


File: dmd.info,  Node: Runlevels,  Next: Misc Facilities,  Prev: Services,  Up: Top

Runlevels
*********

   RUNLEVELS DO NOT WORK YET! Do not use them! Ignore this section!

   A "runlevel" makes it easier to start and stop groups of services,
to bring the system into a certain state.  An object of class
`<runlevel>' is an abstract runlevel, and has the following methods:

 - method: enter (rl <runlevel>) services
     This will be called when the runlevel should be entered.  SERVICES
     is the list of the currently running services.


File: dmd.info,  Node: Misc Facilities,  Next: Internals,  Prev: Runlevels,  Up: Top

Misc Facilities
***************

   This is a list of facilities which are available to code running
inside of dmd and is considered generally useful, but is not directly
related to one of the other topic covered in this manual.

* Menu:

* Errors::         Signalling, handling and ignoring errors.
* Communication::  Input/Output in various ways.
* Others::         Stuff that is useful, but is homeless.


File: dmd.info,  Node: Errors,  Next: Communication,  Up: Misc Facilities

Errors
======

 - macro: assert expr
     If EXPR yields `#f', display an appropriate error message and
     throw an `assertion-failed' exception.

 - procedure: caught-error key args
     Tell dmd that a KEY error with ARGS has occured.  This is the
     simplest way to cause caught error result in uniformly formated
     warning messages.  The current implementation is not very good,
     though.

 - procedure: call/cc proc
     An alias for `call-with-current-continuation'.

 - procedure: call/ec proc
     A simplistic implementation of the nonstandard, but popular
     procedure `call-with-escape-continuation', i.e. a `call/cc' for
     outgoing continuations only.  Note that the variant included in
     dmd is not aware of `dynamic-wind' at all and does not yet support
     returning multiple values.

 - macro: without-system-error expr...
     Evaluates the EXPRs, not going further if a system error occurs,
     but also doing nothing about it.


File: dmd.info,  Node: Communication,  Next: Others,  Prev: Errors,  Up: Misc Facilities

Communication
=============

 - procedure: local-output format-string . args
     This procedure should be used for all output operations in dmd.  It
     outputs the ARGS according to the FORMAT-STRING, then inserts a
     newline.  It writes to whatever is the main output target of dmd,
     which might be multiple at the same time in future versions.

   For paket-based communication over a Unix Domain Socket, there are
two classes.  They exist to make it easiely possible to use pakets of
arbitrary size.  To receive data, you use an instance of the class
`<receiver>'.  This can be done this way:

     (define my-receiver (make <receiver> "/tmp/socket-name"))

   A `<receiver>' has the following method:

 - method: receive-data (obj <receiver>)
     This will return a string containing the data of the next paket.

   Sending data so that a `<receiver>' understands it can be done with
the class `<sender>'.  You can create an instance like this:

     (define my-sender (make <sender> "/tmp/socket-name"))

   The class `<sender>' has the following method:

 - method: send-data (obj <sender) data
     Send DATA to the sender object OBJ.  You should always use this
     when the receiver-side is using a `<receiver>' object.


File: dmd.info,  Node: Others,  Prev: Communication,  Up: Misc Facilities

Others
======

 - procedure: copy-hashq-table table new-size
     Create a hash-table with size NEW-SIZE, and insert all values from
     TABLE into it, using `eq?' when inserting.  This procedure is
     mainly used internally, but is a generally useful utillity, so it
     can by used by everyone.


File: dmd.info,  Node: Internals,  Next: Concept Index,  Prev: Misc Facilities,  Up: Top

Internals
*********

   This chapter contains information about the design and the
implementation details of dmd for people who want to hack dmd itself.
If you want your work to get included in dmd, please contact me and say
what you intend to do so that I can give advice on how to do it and we
can avoid duplicating work.  My development version is usually a bit
ahead of what I release, as I only want to publish code that got some
testing.

* Menu:

* Coding standards::    How to properly hack dmd.
* Design decisions::    Why dmd is what it is.
* Service Internals::   How services actually work.
* Runlevel evolution::  Learning from past mistakes.


File: dmd.info,  Node: Coding standards,  Next: Design decisions,  Up: Internals

Coding standards
================

   About formatting: Use common sense and GNU Emacs (which actually is
the same, of course), and you almost can't get the formatting wrong.
Notable exceptions: Indent `if' like it is done in ELisp, and `catch'
also deserves a better indenting.  This can be achieved by putting this
in your `~/.emacs':

     (put 'if 'scheme-indent-function 2)
     (put 'catch 'scheme-indent-function 1)

   This section will be extended in the future...


File: dmd.info,  Node: Design decisions,  Next: Service Internals,  Prev: Coding standards,  Up: Internals

Design decisions
================

   The general idea of a service manager that uses dependencies, similar
to those of a Makefile, came from the developers of the GNU Hurd, but
as few people are satisfied with System V Init, many other people had
the same idea independently.  Nevertheless, dmd was written with the
goal of becoming a replacement for System V Init on GNU/Hurd, which was
one of the reasons for choosing the extension language of the GNU
project, Guile, for implementation (another reason being that it makes
it just so much easier).

   The runlevel concept (i.e. thinking in _groups_ of services) is
sometimes useful, but often one also wants to operate on single
services.  System V Init makes this hard: While you can start and stop
a service, `init' will not know about it, and use the runlevel
configuration as its source of information, opening the door for
inconsistencies (which fortunatly are not a practical problem usually).
In dmd, this was avoided by having a central entity that is
responsible for starting and stopping the services, which therefore
knows which services are actually started (if not completely inproperly
used, but that is a requirement which is impossible to avoid anyway).
While runlevels are not implemented yet, it is clear that they will sit
on top of the service concept, i.e. runlevels will merely be an
optional extension that the service concept does not rely on.  This
also makes changes in the runlevel design easier when it may become
necessary.

   The consequence of having a daemon running that controls the services
is that we need another program as user interface which communicates
with the daemon.  Fortunatly, this makes the commands necessary for
controlling services pretty short and intuitive, and gives the
additional bonus of adding some more flexibility.  For example, it is
easiely possible to grant password-protected control over certain
services to unprivileged users, if desired.

   An essential aspect of the design of dmd (which was already mentioned
above) is that dmd should always know exactly what is happening, i.e.
which services are started and stopped.  The alternative would have
been to not use a daemon, but to save the state on the file system,
again opening the door for inconsistencies of all sorts.  Also, we
would have to use a seperate program for respawning a service (which
just starts the services, waits until it terminates and then starts it
again).  Killing the program that does the respawning (but not the
service that is supposed to be respawned) would cause horrible
confusion.  My understanding of "The Right Thing" is that this
conceptionally limited strategy is exactly what we do not want.

   The way dependencies work in dmd took a while to mature, as it was
not easy to figure out what is appropriate.  I decided to not make it
too sophisticated by trying to guess what the user might want just to
theoretically fulfill the request we are processing.  If something goes
wrong, it is usually better to tell the user about the problem and let
her fix it, taking care to make finding solutions or workarounds for
problems (like a misconfigured service) easy.  This way, the user is in
control of what happens and we can keep the implementation simple.  To
make a long story short, _we don't try to be too clever_, which is
usually a good idea in developing software.

   If you wonder why I was giving a "misconfigured service" as an
example above, consider the following situation, which actually is a
wonderful example for what was said in the previous paragraph: Service
X depends on symbol S, which is provided by both A and B.  A depends on
AA, B depends on BB.  AA and BB conflict with each other.  The
configuration of A contains an error, which will prevent it from
starting; no service is running, but we want to start X now.  In
resolving its dependencies, we first try to start A, which will cause
AA to be started.  After this is done, the attempt of starting A fails,
so we go on to B, but its dependency BB will fail to start because it
conflicts with the running service AA.  So we fail to provide S, thus X
cannot be started.  There are several possibilities to deal with this:

   * When starting A fails, terminate those services which have been
     started in order to fulfill its dependencies (directly and
     indirectly).  In case AA was running already, we would not want to
     terminate it.  Well, maybe we would, to avoid the conflict with BB.
     But even if we would find out somehow that we need to terminate AA
     to eventually start X, is the user aware of this and wants this to
     happen (assuming AA was running already)?  Probably not, she very
     likely has assumed that starting A succeeds and thus terminating
     AA is not necessary.  Remember, unrelated (running) services might
     depend in AA.  Even if we ignore this issue, this strategy is not
     only complicated, but also far from being perfect: Let's assume
     starting A succeeds, but X also depends on a service Z, which
     requires BB.  In that case, we would need to detect in the first
     place that we should not even try to start A, but directly satisfy
     X's dependency on S with B.

   * We could do it like stated above, but stop AA only if we know we
     won't need it anymore (for resolving further dependencies), and
     start it only when it does not conflict with anything that needs
     to get started.  But should we stop it if it conflicts with
     something that _might_ get started?  (We do not always know for
     sure what we will start, as starting a service might fail and we
     want to fall back to a service that also provides the particular
     required symbol in that case.)  I think that either decision will
     be bad in one case or another, even if this solution is already
     horribly complicated.

   * When we are at it, we could just calculate a desired end-position,
     and try to get there by starting (and stopping!) services,
     recalculating what needs to be done whenever starting a service
     fails, also marking that particular service as unstartable, except
     if it fails to start because a dependency could not be resolved
     (or maybe even then?).  This is even more complicated.  Instead of
     implementing this and thereby producing code that (a) nobody
     understands, (b) certainly has a lot of bugs, (c) will be
     unmaintainable and (d) causes users to panic because they won't
     understand what will happen, I decided to do the following instead:

   * Just report the error, and let the user fix it (in this case, fix
     the configuration of A) or work around it (in this case, disable A
     so that we won't start AA but directly go on to starting B).

   I hope you can agree that the latter solution after all is the best
one, because we can be sure to not do something that the user does not
want us to do.  Software should not run amok.  This explanation was
very long, but I think it was necessary to justify why dmd uses a very
primitive algorithm to resolve dependencies, despite the fact that it
could theoretically be a bit more clever in certain situations.

   One might argue that it is possible to ask the user if the planned
actions are ok with her, and if the plan changes ask again, but
especially given that services are supposed to usually work, I see few
reasons to make the source code of dmd more complicated than necessary.
If you volunteer to write _and_ maintain a more clever strategy (and
volunteer to explain it to everyone who wants to understand it), you
are welcome to do so, of course...


File: dmd.info,  Node: Service Internals,  Next: Runlevel evolution,  Prev: Design decisions,  Up: Internals

Service Internals
=================


File: dmd.info,  Node: Runlevel evolution,  Prev: Service Internals,  Up: Internals

Runlevel evolution
==================

   This section describes how the runlevel concept evolved over time.
This is basically a collection of mistakes, but is provided here for
your information, and possibly for your amusement, but I'm not sure if
all this weird dependency stuff is really that funny.

* Menu:

* Runlevel assumptions::    What runlevels should be like
* Runlevels - part one::    The first attempts of making it work
* Runlevels - part two::    It should work... somehow...


File: dmd.info,  Node: Runlevel assumptions,  Next: Runlevels - part one,  Up: Runlevel evolution

Runlevel assumptions
--------------------

   A runlevel is a system state, i.e. it consists of the information
about which services are supposed to be available and which not.  This
vague definition implies that several different runlevel styles can be
implemented in a service manager.

   For example, you can do it like System V Init, specifying which
services should be started when we enter a runlevel and which ones
should be stopped when leaving it.  But one could also specify for
every service in which runlevels it should be running.

   In dmd, we do not want to limit ourselfes to a single runlevel style.
We allow for all possible strategies to be implemented, providing the
most useful ones as defaults.  We also want to make it possible to
combine the different styles arbitrariely.

   Therefore, when entering a runlevel, we call a user-defined piece of
code, passing it the list of currently active services and expecting as
the result a list of service symbols which tell us which services we
want to have running.  This interface makes it very easy to implement
runlevel styles, but makes it not-so-easy for the runlevel
implementation itself, because we have to get from the current state
into a desired state, which might be more or less vague (since it is
not required to be a list of canonical names).  Obviously service
conflicts and already running services need to be taken into account
when deciding which services should be used to provide the various
symbols.

   Also, the runlevel implementation should be implemented completely on
top of the service concept, i.e. the service part should not depend on
the idea of runlevels or care about them at all.  Otherwise
understanding the service part (which is the most essential aspect of
dmd) would become harder than necessary.


File: dmd.info,  Node: Runlevels - part one,  Next: Runlevels - part two,  Prev: Runlevel assumptions,  Up: Runlevel evolution

Runlevels, part one
-------------------

   I came up with the following method (here in Pseudo-Scheme), which is
possibly slightly buggy, but should give you the idea:

     ;; Beginning with the canonical names in CURRENT-SERVICES, start and
     ;; stop services until getting into a state where everything requested
     ;; in TARGET-SERVICES (which does not only consist of canonical names)
     ;; is provided, and the things they depends on, but no more.
     (define (switch-runlevel current-services target-services)
       (let ((target-services-backup target-services)
     	(unstartable '()))
         (let retry ()
           (repeat-until-none-of-these-changes-annythig
            ;; Replace all of them with canonical names which provide them.
            (canonicalize-names! target-services unstartable current-services)
            ;; Add what we need additionally.
            (add-dependencies! target-services unstartable current-services))
           (remove-redundancy! target-services)
           (stop-all-unneeded target-services)
           (catch 'service-could-not-be-started
     	     (lambda ()
     	       ;; Iterate over the list, starting only those which
     	       ;; have all dependencies already resolved, so nothing
     	       ;; we don't want will be started.  Repeat until done.
     	       (carefully-start target-services))
     	     (lambda (key service)
     	       (set! unstartable (cons service unstartable))
     	       (set! target-services backup-target-services)
     	       (set! current-services (compute-current-services))
     	       (retry))))))

   This indeed looks like a nice way to get what we want.  However, the
details of this are not as easy as it looks like.  When replacing
virtual services with canonical names, we have to be very careful.
Consider the following situation:

   The virtual service X is provided by both A and B, while Y is
provided only by B.  We want to start C (which depends on X) and D
(which depends on Y).  Obviously we should use B to fulfill the
dependency of C and D on X and Y, respectively.  But when we see that
we need something that provides X, we are likely to do the wrong thing:
Select A.  Thus, we need to clean this up later. I wanted to do this as
follows:

   While substituting virtual services with canonical names, we also
safe which one we selected to fulfill what, like this:

     ((A . (X))
      (B . (Y)))

   Later we look for conflicts, and as A and B conflict, we look which
one can be removed (things they provide but are not required by anyone
should be ignored, thus we need to create a list like the above).  In
this case, we can replace A with B as B also provides X (but A does not
provide Y, thus the reverse is impossible).  If both could be used, we
probably should decide which one to use by looking at further
conflicts, which gets pretty hairy.  But, in this case, we are lucky
and end up with this:

     ((B . (X Y)))

   This way of finding out which service we should use in case of
conflicts sounds pretty sane, but if you think it will work well, you
have been fooled, because actually it breaks horribly in the following
situation:

Service Provides
A       `W X Y -'
B       `W X - Z'
C       `- X Y Z'
D       `W - - -'

   If we need all of W, X, Y and Z, then obviously we need to take C and
D.  But if we have a list like this, we cannot fix it:

     ((A . (W X Y))
      (B . (Z)))

   Thus, we cannot do it this way.


File: dmd.info,  Node: Runlevels - part two,  Prev: Runlevels - part one,  Up: Runlevel evolution

Runlevels, part two
-------------------

   Let's look again at the table at the end of part two:

Service Provides
A       `W X Y -'
B       `W X - Z'
C       `- X Y Z'
D       `W - - -'

   If from this table it is so obvious for us what we should do, then it
should also be possible to calculate it for a computer, given such a
table as input.  Ok, we have to take into account conflicts that are
not visible in this table, but the general idea is usable.  But how do
we find which combination works?  I found only one way yet: Kind of a
brute force attack: Try combinations until we find one that works.

   This alone would be too slow.  With 20 services we would have 2^20
possible combinations, that is a bit more than a million.  Fortunatly,
we can optimize this.  First I thought we could remove all services
from the list that do not provide any symbol we need, but that is
obviously a stupid idea, as we might need them for dependencies, in
which case we need to take into account their conflicts.  But the
following method would work:

   Very often a symbol that is required will be a canonical name
already, i.e. be provided only by a single service.  Using our example
above, let's suppose we also need the symbol V, which is provided only
by D.  The first step we do is to look which (required) symbols are
provided only by a single service, as we will need this service for
sure.  In this case, we would need D.  But by using it, we would also
get the other symbols it provides, W in this case.  This means that we
don't need to bother looking at other services that provide W, as we
cannot use them because they conflict with a service that we definitely
need.  In this case, we can remove A and B from the list this way.
Note that we can remove them entirely, as all their conflicts become
irrelevant to us now.  In this simple case we would not even have to do
much else, C is the only remaining service.

   After this first step, there remain the symbols that are provided by
two or more services.  In every combination we try, exactly one of them
must be used (and somehow we should take into account which services
are running already).  This also reduces the amount of possible
combinations a lot.  So what remains after that are the services we
might need for fulfilling dependencies.  For them, we could try all
combinations (2^n), making sure that we always try subsets before any
of their supersets to avoid starting unneeded services.  We should take
into account which services are already running as well.

   The remaining question is, what to do if starting a service fails.  A
simple solution would be to recursively remove all services that depend
on it directly or indirectly.  That might cause undesired side-effects,
if a service was running but it had to be stopped because one of the
services that provides something it depends on gets exchanged for
another service that provides the same symbol, but fails to start.  The
fact that we would have to stop the (first) service is a problem on its
own, though.


File: dmd.info,  Node: Concept Index,  Next: Procedure and Macro Index,  Prev: Internals,  Up: Top

Concept Index
*************

* Menu:

* <service>, slots of:                   Slots of services.
* Addition actions of services:          Slots of services.
* assertions:                            Errors.
* canonical names of services:           Slots of services.
* configuration file:                    Jump Start.
* constructors, generation of:           Service De- and Constructors.
* daemon:                                deco and dmd.
* daemon controller:                     deco and dmd.
* deco:                                  deco and dmd.
* deco Invocation:                       Invoking deco.
* destructors, generation of:            Service De- and Constructors.
* dmd:                                   deco and dmd.
* dmd Invocation:                        Invoking dmd.
* dmd service:                           The dmd and unknown services.
* Extra actions of services:             Slots of services.
* fallback service:                      The dmd and unknown services.
* fallback services:                     Jump Start.
* generating constructors:               Service De- and Constructors.
* generating destructors:                Service De- and Constructors.
* GOOPS:                                 Introduction.
* Guile:                                 Introduction.
* hashes:                                Others.
* Hook for individual services:          Slots of services.
* insecure:                              Invoking dmd.
* invoking deco:                         Invoking deco.
* invoking dmd:                          Invoking dmd.
* log file:                              Invoking dmd.
* logging:                               Invoking dmd.
* output:                                Communication.
* prefix:                                Jump Start.
* relative file names:                   deco and dmd.
* Respawning services:                   Slots of services.
* runlevel:                              Runlevels.
* Scheme:                                Introduction.
* security:                              Invoking dmd.
* service:                               Services.
* Service constructor:                   Slots of services.
* Service destructor:                    Slots of services.
* service manager:                       Introduction.
* slots of <service>:                    Slots of services.
* socket special file <1>:               Invoking deco.
* socket special file:                   Invoking dmd.
* special services:                      The dmd and unknown services.
* Starting a service:                    Slots of services.
* Stoping a service:                     Slots of services.
* system errors:                         Errors.
* unknown service:                       The dmd and unknown services.
* virtual services:                      Jump Start.


File: dmd.info,  Node: Procedure and Macro Index,  Next: Variable Index,  Prev: Concept Index,  Up: Top

Procedure and Macro Index
*************************

* Menu:

* assert:                                Errors.
* call/cc:                               Errors.
* call/ec:                               Errors.
* canonical-name:                        Methods of services.
* caught-error:                          Errors.
* conflicts-with:                        Methods of services.
* copy-hashq-table:                      Others.
* default-display-status:                Methods of services.
* enter:                                 Runlevels.
* extra-action <1>:                      Service Convenience.
* extra-action:                          Methods of services.
* find-running:                          Service Convenience.
* for-each-service:                      Service Convenience.
* local-output:                          Communication.
* lookup-services:                       Service Convenience.
* make-childexec-constructor:            Service De- and Constructors.
* make-extra-actions:                    Service Convenience.
* make-kill-destructor:                  Service De- and Constructors.
* make-system-constructor:               Service De- and Constructors.
* make-system-destructor:                Service De- and Constructors.
* provided-by:                           Methods of services.
* receive-data:                          Communication.
* register-services:                     Service Convenience.
* required-by:                           Methods of services.
* respawn?:                              Methods of services.
* running?:                              Methods of services.
* send-data:                             Communication.
* start <1>:                             Service Convenience.
* start:                                 Methods of services.
* stop <1>:                              Service Convenience.
* stop:                                  Methods of services.
* without-system-error:                  Errors.


File: dmd.info,  Node: Variable Index,  Next: Type Index,  Prev: Procedure and Macro Index,  Up: Top

Variable Index
**************

* Menu:

* enabled? (slot of <service>):          Slots of services.
* extra-actions (slot of <service>):     Slots of services.
* last-respawns (slot of <service>):     Slots of services.
* provides (slot of <service>):          Slots of services.
* requires (slot of <service>):          Slots of services.
* respawn? (slot of <service>):          Slots of services.
* running (slot of <service>):           Slots of services.
* start (slot of <service>):             Slots of services.
* stop (slot of <service>):              Slots of services.
* stop-delay? (slot of <service>):       Slots of services.
* waiting-for-termination? (slot of <service>): Slots of services.


File: dmd.info,  Node: Type Index,  Prev: Variable Index,  Up: Top

Type Index
**********

* Menu:

* <receiver>:                            Communication.
* <runlevel>:                            Runlevels.
* <sender>:                              Communication.
* <service>:                             Services.



Tag Table:
Node: Top208
Node: Introduction1173
Node: Jump Start2684
Node: deco and dmd9823
Ref: deco and dmd-Footnote-110724
Node: Invoking dmd10835
Node: Invoking deco12107
Node: Services13366
Node: Slots of services14238
Node: Methods of services19229
Node: Service Convenience21597
Node: Service De- and Constructors23370
Node: Service Examples24991
Node: The dmd and unknown services25981
Node: Runlevels27346
Node: Misc Facilities27892
Node: Errors28388
Node: Communication29432
Node: Others30766
Node: Internals31145
Node: Coding standards31894
Node: Design decisions32453
Node: Service Internals40209
Node: Runlevel evolution40358
Node: Runlevel assumptions40939
Node: Runlevels - part one42848
Node: Runlevels - part two46455
Node: Concept Index49605
Node: Procedure and Macro Index52540
Node: Variable Index54624
Node: Type Index55436

End Tag Table
